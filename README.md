# Comptage

## 思路

首先，我们使用 produce_upchirp.py 脚本生成仅包含 LoRa 上升 chirp 的基带二进制文件，文件中分别包含 1、2、4、6 和 8 个 upchirp，用于研究不同前导码长度对 chirp 检测性能的影响。

随后，在发送端引入随机性，通过 tx_random.py 脚本在 10 秒的观测时间窗口内随机发送这些 chirp 信号，以模拟节点之间异步、随机接入的通信场景。

在接收端，本地生成一个与发送端参数一致的 LoRa 上升 chirp 作为参考信号。通过将接收信号与该参考 chirp 的共轭相乘，实现 dechirp 操作。
若接收信号中存在 LoRa chirp，该操作会将其线性扫频特性转化为近似恒定频率分量，从而在频域中产生明显的单频(以一个固定的速度转动)峰值。

FFT 用来判断信号中是否存在稳定的频率分量。在本实验中，通过 dechirp 操作将 LoRa chirp 转化为近似单频信号，使得 FFT 能够以峰值形式检测 chirp 的存在。

随后对 dechirp 后的信号进行 FFT 频域分析，通过观察频谱中的波峰特征来判断 chirp 是否被成功接收。当接收到 chirp 信号时，其对应的频谱中会出现明显高于噪声底的波峰，从而实现对 chirp 存在性的检测。

![FFT 峰值示意图](figure/fft_1up.png)
![FFT 峰值示意图](figure/fft_2up.png)
![FFT 峰值示意图](figure/fft_4up.png)
![FFT 峰值示意图](figure/fft_6up.png)
![FFT 峰值示意图](figure/fft_8up.png)

## 思路 english



## 实验仿真

1. 所有节点相同，本实验旨在评估一种基于极简信令的节点检测方法在高密度 LoRa 网络中的有效性。所有节点均发送相同的序列信号（单个 chirp），不携带任何节点标识或数据信息。在固定的观测时间窗口内（100 000 ms），各节点随机选择发送时刻进行序列发送。

由于采用随机接入方式，不同节点的发送可能在时间上发生重叠或间隔过近，从而导致碰撞，使得对应序列无法被成功检测。若某一节点在整个观测窗口内至少有一次发送未发生碰撞，则认为该节点被成功检测。

通过 Monte-Carlo 仿真，在不同节点数量条件下统计可被检测到的节点数量，从而分析该方法在节点规模增大时的检测能力和性能极限。

2. 
每个节点通过在时间轴上发送多个 chirp 形成特定的时间结构模式来进行标识，而不是依赖单个 chirp 或完整的数据帧。该标识信息分布在多个离散的时间位置上，体现在 chirp 之间的相对时序关系中。当多个节点同时发送而产生部分碰撞时，虽然部分 chirp 可能丢失，但时间结构的局部特征往往仍然得以保留。只要接收端观测到的 chirp 数量和时间位置与某一节点的时间结构模式具有足够的一致性，就可以判定该节点的存在。因此，该方法能够在存在部分碰撞的情况下实现节点检测，具有较强的鲁棒性。


## 思路1优化1chirp
分为六步写的，第一是写么随即生成N个noeud,只在N个点分别选择了不同的时间发送，这个区间大概是在0-100000ms-1.024ms期间，因为一次chirp的发送设定的是1.024ms.

第二步是排序，因为生成了那个点，所以需要排序，比如有的大有的小，这样就需要用到**np.sort**.
第三步是加入一个碰撞时间，这里是2中方式，第一中是在0-1.024这一个chirp里如果检测到其他的chirp,其他chirp的起始点在这个内，不管多少个全部认为碰撞只保留1各，第二种是一个都不保留。

第四步就是加入一个**trial**，这个的意思就是一次完整的随机试验，我前面做的一整套就是一次随即试验，但是每一次都有可能不一样，我们最好做很多次trial.
第五步就是把固定的n变成一个list。
mean 看数量，std 看波动，ratio 看成功概率。


## 思路2seq

***唯一序列上限是 2^(L-2不同的序列)*** 目前先不用这个不同的序列

首先，**第一步**我先生成了首尾是 1 的，N 个独一无二的序列，这里用到了**seed**,seed 是随机种子
相同的 **seed** → 每次生成的序列都一样
不同的 **seed** → 序列会不一样.
还用到了**p=0.5**，通过判断大于p来产生1和0.
在每次生成一条新的随机序列后，将其转换为一个不可变的元组 key，用于在集合 seen 中进行快速查重，从而保证每个节点被分配到的序列是唯一的。**set**就是 用来快速存放并检查这些指纹，从而保证每个序列都是唯一的。****tuple**把序列变成“不可变的指纹”.
随机性（seed） 用于构造大量不同但可复现的实验实例；
set + tuple 是核心工具，用于保证模板唯一性和检测去重；

**第二步**，将总时间分为不同的槽，比如总时间是 10 s，一个 chirp 是 1 ms，那么按 1 ms 分”。把连续时间，换算成离散的 chirp 槽个数。这里用到了**np.floor**,不管小数是多少，直接砍掉小数部分，往小的整数走,这样保证了槽的可用性。知道了总时间可以分为多少槽
**第三步**，就是给N各节点都选择一个起始槽，同时要满足最后一个点是小于M-L+1,因为用到了**np.random.randint(0, M - L + 1)**，这个意思就是产生一个整数，大于等于0小于M-L+1,覆盖所有的情况。，创建随即发送可以使用的槽，注意是起始槽，就是规定了每个节点发送的起始槽的位置
**第四步**，就是设置为每个节点打算在哪些位置发送变成在整个时间轴的哪几个槽发送，我们可以知道时间轴上的 1 在哪里。
**第五步**，就是在接受端上，现在把所有的节点里发得1都放到接收端里
**第六步**， 首先用到了**shape** 告诉你 seq 有多少行和多少列，也就是 N（节点数）和 L（序列长度）。先将每个节点的模板序列用 tuple() 转换为键，建立模板到节点编号的字典。随后在接收序列 y 上用长度为 L 的滑动窗口逐点扫描，将窗口内容同样转为 tuple() 并查字典。若窗口与某模板完全一致，则判定对应节点被检测到，并用 set() 去重，同一节点只计一次。最终统计被检测到的不同节点数量。


**相同的序列**
1.还有一个就是产生完全一样的序列，2种方式检测，一种是跳L,防止大于1.
2.一种是不跳L,导致可能会出现大于1的。
3.anais的方法，剥皮法

**Lorawan仿真**
LoRaWAN 的节点是在某个时间点开始发一整帧（trame）”。因为lora帧是连续的，所以，
如果两帧在时间上重叠，就发生碰撞，这两帧都算失败；
如果一帧在它的整个发送时间内没有别人发，就算成功 +1。
完全仿真lora的话12.25 + 33 = 45.25symbol,45.25
premble 12.25chirp
我发送的数据假设为1byte 需要加上
FHDR7
= DevAddr 4B
FCtrl 1B
FCnt 2B
FOpts 0B（最小情况）
再加上MIC 4byte
Fport 1byte 因为我们有数据
还有mhdr 1byte.
使用公式可以计算出14byte等于33chirp

我们将每一次 LoRaWAN 帧发送建模为一个连续的时间区间 
[ti,ti+Tframe)
首先对所有帧的开始时间进行排序，然后沿时间轴从最早开始的帧向右扫描。以当前帧为起点，维护一个变量表示当前碰撞簇的结束时间，并不断将所有开始时间早于该结束时间的后续帧并入同一簇，同时更新簇的结束时间为其中最晚的帧结束时刻。当下一个帧的开始时间不再早于该结束时间时，当前簇结束。若该簇仅包含一帧，则该帧被判定为成功；若簇内包含多于一帧，则认为发生碰撞，簇内所有帧均失败。

acc.mean 平均，acc.std 标准差



